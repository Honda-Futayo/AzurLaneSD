<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>碧蓝航线SD小人图鉴</title>
	<script src="./build/spine-webgl.js"></script>
	<script src="./jquery-3.1.0.min.js"></script>
	<link rel="stylesheet" href="style.css">
</head>
<body>
	<canvas id="canvas"></canvas>
	<center>
		<div style="color: #fff; position: fixed; top: 0; width: 100%">
			<span>Skeleton:</span><select id="skeletonList"></select>
			<span>Animation:</span><select id="animationList"></select>
		</div>
	</center>
	<div class="spinner" id="loading">
		<div class="spinner-container container1">
			<div class="circle1"></div>
			<div class="circle2"></div>
			<div class="circle3"></div>
			<div class="circle4"></div>
		</div>
		<div class="spinner-container container2">
			<div class="circle1"></div>
			<div class="circle2"></div>
			<div class="circle3"></div>
			<div class="circle4"></div>
		</div>
		<div class="spinner-container container3">
			<div class="circle1"></div>
			<div class="circle2"></div>
			<div class="circle3"></div>
			<div class="circle4"></div>
		</div>
	</div>
	<a href="https://github.com/Pelom777/AzurLaneSD" class="github-corner" target="_blank" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>
	<div id="copyright">
        author:<a target="_blank" href="https://pelom.top/">Pelom</a><br>
        请勿用于商业用途
    </div>
</body>
<script>
	
var lastFrameTime = Date.now() / 1000;
var json;
var url="name.json";
var change = false;
var loaded = false;
var canvas;
var loading;
var shader;
var batcher;
var gl;
var mvp = new spine.webgl.Matrix4();
var assetManager;
var skeletonRenderer;
var debugRenderer;
var shapes;
var chosenSkeleton = "22";
var activeSkeleton;
var swirlEffect = new spine.SwirlEffect(0);
var jitterEffect = new spine.JitterEffect(20, 20);
var swirlTime = 0;

function loadJson() {
	//load name list.
    var request = new XMLHttpRequest();
    request.open("get", url);
    request.send(null);
    request.onload = function () {
        if (request.status == 200) {
            json = JSON.parse(request.responseText);
            // console.log(json);
        }
    }
}

function init () {
	// Setup canvas and WebGL context. We pass alpha: false to canvas.getContext() so we don't use premultiplied alpha when
	// loading textures. That is handled separately by PolygonBatcher.
	canvas = document.getElementById("canvas");
	loading = document.getElementById("loading");
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	var config = { alpha: false };
	gl = canvas.getContext("webgl", config) || canvas.getContext("experimental-webgl", config);
	if (!gl) {
		alert('WebGL is unavailable.');
		return;
	}

	// Create a simple shader, mesh, model-view-projection matrix and SkeletonRenderer.
	shader = spine.webgl.Shader.newTwoColoredTextured(gl);
	batcher = new spine.webgl.PolygonBatcher(gl);
	mvp.ortho2d(0, 0, canvas.width - 1, canvas.height - 1);
	skeletonRenderer = new spine.webgl.SkeletonRenderer(gl);
	debugRenderer = new spine.webgl.SkeletonDebugRenderer(gl);
	debugRenderer.drawRegionAttachments = true;
	debugRenderer.drawBoundingBoxes = true;
	debugRenderer.drawMeshHull = true;
	debugRenderer.drawMeshTriangles = true;
	debugRenderer.drawPaths = true;
	debugShader = spine.webgl.Shader.newColored(gl);
	shapes = new spine.webgl.ShapeRenderer(gl);
	assetManager = new spine.webgl.AssetManager(gl);

	// Tell AssetManager to load the resources for each model, including the exported .json file, the .atlas file and the .png
	// file for the atlas. We then wait until all resources are loaded in the load() method.

	loadJson();

	// for(var i in json){
	// 	console.log(json[i]);
	// 	assetManager.loadText("assets/AL/" + json[i] + "/" + json[i] + ".json");
	// 	assetManager.loadTextureAtlas("assets/AL/" + json[i] + "/" + json[i] + ".atlas");
	// }
	
	assetManager.loadText("assets/AL/" + chosenSkeleton + "/" + chosenSkeleton + ".json");
	assetManager.loadTextureAtlas("assets/AL/" + chosenSkeleton + "/" + chosenSkeleton + ".atlas");
	
	// setupUI();

	requestAnimationFrame(load);
}

function choose(name){
	change = true;
	assetManager.loadText("assets/AL/" + name + "/" + name + ".json");
	assetManager.loadTextureAtlas("assets/AL/" + name + "/" + name + ".atlas");
	chosenSkeleton = name;
}

function load() {
	loading.style.display = "block";
	// console.log("load:" + assetManager.isLoadingComplete());
	// Wait until the AssetManager has loaded all resources, then load the skeletons.
	if (assetManager.isLoadingComplete()) {
		// for(i in json){
		// 	skeletons[json[i]] = loadSkeleton(json[i], "normal", false);
		// }
		activeSkeleton = loadSkeleton(chosenSkeleton, "normal", false);
		change = false;
		if(!loaded){
			setupUI();
		}
		setupAnimationUI();
		loaded = true;
		requestAnimationFrame(render);
	} else {
		requestAnimationFrame(load);
	}
}

function loadSkeleton (name, initialAnimation, premultipliedAlpha, skin) {
	if (skin === undefined) skin = "default";

	// Load the texture atlas using name.atlas from the AssetManager.
	atlas = assetManager.get("assets/AL/" + name + "/" + name + ".atlas");

	// Create a AtlasAttachmentLoader that resolves region, mesh, boundingbox and path attachments
	atlasLoader = new spine.AtlasAttachmentLoader(atlas);

	// Create a SkeletonJson instance for parsing the .json file.
	var skeletonJson = new spine.SkeletonJson(atlasLoader);

	// Set the scale to apply during parsing, parse the file, and create a new skeleton.
	var skeletonData = skeletonJson.readSkeletonData(assetManager.get("assets/AL/" + name + "/" + name + ".json"));
	var skeleton = new spine.Skeleton(skeletonData);
	skeleton.setSkinByName(skin);
	var bounds = calculateBounds(skeleton);

	// Create an AnimationState, and set the initial animation in looping mode.
	animationStateData = new spine.AnimationStateData(skeleton.data);
	var animationState = new spine.AnimationState(animationStateData);
	animationState.setAnimation(0, initialAnimation, true);

	// Pack everything up and return to caller.
	return { skeleton: skeleton, state: animationState, bounds: bounds, premultipliedAlpha: premultipliedAlpha };
}

function calculateBounds(skeleton) {
	skeleton.setToSetupPose();
	skeleton.updateWorldTransform();
	var offset = new spine.Vector2();
	var size = new spine.Vector2();
	skeleton.getBounds(offset, size, []);
	return { offset: offset, size: size };
}

function setupAnimationUI(){
	var animationList = $("#animationList");
	animationList.empty();
	var skeleton = activeSkeleton.skeleton;
	var state = activeSkeleton.state;
	var activeAnimation = state.tracks[0].animation.name;
	for (var i = 0; i < skeleton.data.animations.length; i++) {
		var name = skeleton.data.animations[i].name;
		var option = $("<option></option>");
		option.attr("value", name).text(name);
		if (name === activeAnimation) option.attr("selected", "selected");
		animationList.append(option);
	}
	animationList.change(function() {
		var state = activeSkeleton.state;
		var skeleton = activeSkeleton.skeleton;
		var animationName = $("#animationList option:selected").text();
		skeleton.setToSetupPose();
		state.setAnimation(0, animationName, true);
	})
}

function setupUI () {
	var skeletonList = $("#skeletonList");
	for (var i in json) {
		skeletonName = json[i];
		var option = $("<option></option>");
		option.attr("value", skeletonName).text(skeletonName);
		if (skeletonName === activeSkeleton) option.attr("selected", "selected");
		skeletonList.append(option);
	}

	skeletonList.change(function() {
		choose($("#skeletonList option:selected").text());
		// setupAnimationUI();
	})
	// setupAnimationUI();
}

function render () {
	loading.style.display = "none";
	// console.log("render:" + assetManager.isLoadingComplete());
	if(change){
		load();
		return;
	}
	var now = Date.now() / 1000;
	var delta = now - lastFrameTime;
	lastFrameTime = now;

	// Update the MVP matrix to adjust for canvas size changes
	resize();

	gl.clearColor(0.3, 0.3, 0.3, 1);
	gl.clear(gl.COLOR_BUFFER_BIT);

	// Apply the animation state based on the delta time.
	var state = activeSkeleton.state;
	var skeleton = activeSkeleton.skeleton;
	var bounds = activeSkeleton.bounds;
	var premultipliedAlpha = activeSkeleton.premultipliedAlpha;
	state.update(delta);
	state.apply(skeleton);
	skeleton.updateWorldTransform();

	// Bind the shader and set the texture and model-view-projection matrix.
	shader.bind();
	shader.setUniformi(spine.webgl.Shader.SAMPLER, 0);
	shader.setUniform4x4f(spine.webgl.Shader.MVP_MATRIX, mvp.values);

	// Start the batch and tell the SkeletonRenderer to render the active skeleton.
	batcher.begin(shader);

	skeletonRenderer.premultipliedAlpha = premultipliedAlpha;
	skeletonRenderer.draw(batcher, skeleton);
	batcher.end();

	shader.unbind();

	requestAnimationFrame(render);
}

function resize () {
	var w = canvas.clientWidth;
	var h = canvas.clientHeight;
	var bounds = activeSkeleton.bounds;
	if (canvas.width != w || canvas.height != h) {
		canvas.width = w;
		canvas.height = h;
	}

	// magic
	var centerX = bounds.offset.x + bounds.size.x / 2;
	var centerY = bounds.offset.y + bounds.size.y / 2;
	var scaleX = bounds.size.x / canvas.width;
	var scaleY = bounds.size.y / canvas.height;
	var scale = Math.max(scaleX, scaleY) * 1.2;
	if (scale < 1) scale = 1;
	var width = canvas.width * scale;
	var height = canvas.height * scale;

	mvp.ortho2d(centerX - width / 2, centerY - height / 2, width, height);
	gl.viewport(0, 0, canvas.width, canvas.height);
}

(function() {
	init();
})();

</script>
</html>